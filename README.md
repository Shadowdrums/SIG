# Unix/Linux Signal (SIG) Reference

This document provides an overview of the signals (SIGs) available in Unix-like operating systems. Signals are used for inter-process communication, allowing processes to be notified of various events.

## Summary of Signals (SIGs)

**Signals (SIGs)** in Unix-like operating systems are a form of inter-process communication that allows the operating system or another process to notify a running process of certain events. These events can include interrupts from the keyboard, illegal operations, or requests to terminate the process. Each signal has a specific purpose and is identified by a name (e.g., `SIGINT`) and a corresponding number.

Signals can be used to control processes, handle unexpected events, and perform cleanup tasks. Some signals can be caught and handled by the process using signal handlers, while others, like `SIGKILL`, cannot be caught or ignored and will immediately terminate the process.

## List of Common Signals

## List of Common Signals

### 1. SIGHUP (1)
- **Description:** Hang up detected on controlling terminal or death of controlling process.
- **Usage:** Often used to reload configuration files without stopping the process.
  
### 2. SIGINT (2)
- **Description:** Interrupt from the keyboard (typically triggered by `Ctrl+C`).
- **Usage:** Used to stop a process from running.

### 3. SIGQUIT (3)
- **Description:** Quit from keyboard (typically triggered by `Ctrl+\\`).
- **Usage:** Causes the process to terminate and produce a core dump.

### 4. SIGILL (4)
- **Description:** Illegal Instruction.
- **Usage:** Indicates that an illegal, invalid, or undefined machine instruction was encountered.

### 5. SIGABRT (6)
- **Description:** Abort signal from abort function.
- **Usage:** Usually generated by the process itself when it calls the `abort()` function.

### 6. SIGFPE (8)
- **Description:** Floating-point exception.
- **Usage:** Generated by a floating-point arithmetic operation, such as division by zero.

### 7. SIGKILL (9)
- **Description:** Kill signal.
- **Usage:** Immediately terminates the process. This signal cannot be caught or ignored.

### 8. SIGSEGV (11)
- **Description:** Invalid memory reference (segmentation fault).
- **Usage:** Indicates an access to a memory location that the process was not allowed to access.

### 9. SIGPIPE (13)
- **Description:** Broken pipe: write to a pipe with no readers.
- **Usage:** Sent to a process when it attempts to write to a pipe that has been closed on the other end.

### 10. SIGALRM (14)
- **Description:** Timer signal from `alarm()` function.
- **Usage:** Used to notify a process that a timer has expired.

### 11. SIGTERM (15)
- **Description:** Termination signal.
- **Usage:** Requests the process to terminate gracefully. This signal can be caught, allowing the process to perform cleanup before exiting.

### 12. SIGUSR1 (10) and SIGUSR2 (12)
- **Description:** User-defined signals.
- **Usage:** Reserved for user-defined purposes in applications.

### 13. SIGCHLD (17)
- **Description:** Child process has stopped or terminated.
- **Usage:** Sent to a parent process when a child process stops or terminates.

### 14. SIGCONT (18)
- **Description:** Continue if stopped.
- **Usage:** Used to resume a process that has been stopped by `SIGSTOP` or `SIGTSTP`.

### 15. SIGSTOP (19)
- **Description:** Stop process.
- **Usage:** Stops (pauses) the process execution. This signal cannot be caught or ignored.

### 16. SIGTSTP (20)
- **Description:** Stop typed at terminal (typically triggered by `Ctrl+Z`).
- **Usage:** Suspends the process temporarily, similar to `SIGSTOP`, but can be resumed with `SIGCONT`.

### 17. SIGTTIN (21)
- **Description:** Background process attempting read.
- **Usage:** Sent to a process that attempts to read input from the terminal while in the background.

### 18. SIGTTOU (22)
- **Description:** Background process attempting write.
- **Usage:** Sent to a process that attempts to write output to the terminal while in the background.

## How to Use Signals in Your Application

You can handle signals in your application using signal handlers. Here is a simple example in C:

```c
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

void handle_sigint(int sig) {
    printf("Caught signal %d\n", sig);
    exit(1);
}

int main() {
    signal(SIGINT, handle_sigint);
    while (1) {
        printf("Running...\n");
        sleep(1);
    }
    return 0;
}
```
```bash
#!/bin/bash

# Function to handle SIGINT (Ctrl+C)
handle_sigint() {
    echo "Caught SIGINT (Ctrl+C)! Cleaning up..."
    # Perform any cleanup tasks here
    exit 0
}

# Trap SIGINT and call handle_sigint when it's received
trap 'handle_sigint' SIGINT

# Main loop
echo "Running... Press Ctrl+C to stop."
while true; do
    # Simulate some work
    sleep 1
done
```
## How the Script Works:
### trap Command: The trap command tells the shell to execute the handle_sigint function when a SIGINT signal is received.
handle_sigint Function: This function handles the SIGINT signal. When Ctrl+C is pressed, this function is executed, allowing the script to perform any cleanup tasks before exiting.
Infinite Loop: The script runs an infinite loop to simulate a long-running process. It continues to run until Ctrl+C is pressed.
### Running the Script:
- Save the script to a file, e.g., sigint_example.sh.
- Make the script executable: chmod +x sigint_example.sh.
- Run the script: ./sigint_example.sh.
- Press Ctrl+C while the script is running to see the signal handling in action.
# Conclusion
Signals are a powerful tool for managing processes and handling inter-process communication in Unix-like operating systems. Understanding how to use and handle signals effectively can greatly enhance your ability to manage and control processes in your applications.
